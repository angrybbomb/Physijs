<!DOCTYPE html>

<html>

<head>
	<title>Jenga - Physijs</title>
	<script type="text/javascript" src="js/ThreeDebug.js"></script>
	<script type="text/javascript" src="js/stats.js"></script>
	<script type="text/javascript" src="../physi.js"></script>
	
	<script type="text/javascript">
	
	'use strict';
	
	// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	// shim layer with setTimeout fallback
	window['requestAnimFrame'] = (function(){
	  return  window.requestAnimationFrame       || 
	          window.webkitRequestAnimationFrame || 
	          window.mozRequestAnimationFrame    || 
	          window.oRequestAnimationFrame      || 
	          window.msRequestAnimationFrame     || 
	          function(/* function */ callback, /* DOMElement */ element){
	            window.setTimeout(callback, 1000 / 60);
	          };
	})();
	
	Physijs.scripts.worker = '../physijs_worker.js';
	Physijs.scripts.ammo = 'examples/js/ammo.js';
	
	var initScene, initEventHandling, render, createTower,
		renderer, stats, scene, light, camera,
		blocks = [], intersect_plane;
	
	initScene = function() {
		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.shadowMapEnabled = true;
		renderer.shadowMapSoft = true;
		document.getElementById( 'viewport' ).appendChild( renderer.domElement );
		
		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		stats.domElement.style.zIndex = 100;
		document.getElementById( 'viewport' ).appendChild( stats.domElement );
		
		scene = new Physijs.Scene;
		scene.setGravity({ x: 0, y: -10, z: 0 });
		
		camera = new THREE.PerspectiveCamera(
			35,
			window.innerWidth / window.innerHeight,
			1,
			1000
		);
		camera.position.set( 30, 20, 30 );
		camera.lookAt(new THREE.Vector3( 0, 5, 0 ));
		scene.add( camera );
		
		// Light
		light = new THREE.DirectionalLight( 0xFFFFFF );
		light.position.set( 40, 60, 25 );
		light.target.position.copy( scene.position );
		light.castShadow = true;
		light.shadowCameraLeft = -30;
		light.shadowCameraTop = -30;
		light.shadowCameraRight = 30;
		light.shadowCameraBottom = 30;
		light.shadowBias = -.0001
		scene.add( light );
		
		// Table
		var table = new Physijs.BoxMesh(
			new THREE.CubeGeometry(50, 1, 50),
			new THREE.MeshLambertMaterial({ color: 0xDDDDDD }),
			0, // mass
			{ restitution: .2, friction: .8 }
		);
		table.position.y = -.5;
		table.receiveShadow = true;
		scene.add( table );
		
		createTower();
		
		intersect_plane = new THREE.Mesh(
			new THREE.PlaneGeometry( 150, 150 ),
			new THREE.MeshBasicMaterial({ opacity: 0 })
		);
		scene.add( intersect_plane );
		intersect_plane.rotation.x = -Math.PI / 2;

		initEventHandling();
		
		requestAnimFrame( render );
	};
	
	render = function() {
		scene.simulate(undefined, 2);
		renderer.render( scene, camera);
		stats.update();
		requestAnimFrame( render );
	};
	
	createTower = (function() {
		var block_length = 6, block_height = 1, block_width = 1.5, block_offset = 2,
			block_geometry = new THREE.CubeGeometry( block_length, block_height, block_width ),
			block_material = new THREE.MeshLambertMaterial({ color: 0xBB7744 });
		
		return function() {
			var i, j, rows = 16,
				block;
			
			for ( i = 0; i < rows; i++ ) {
				for ( j = 0; j < 3; j++ ) {
					block = new Physijs.BoxMesh( block_geometry, block_material );
					block.position.y = (block_height / 2) + block_height * i;
					if ( i % 2 === 0 ) {
						block.rotation.y = Math.PI / 2.01; // #TODO: There's a bug somewhere when this is to close to 2
						block.position.x = block_offset * j - ( block_offset * 3 / 2 - block_offset / 2 );
					} else {
						block.position.z = block_offset * j - ( block_offset * 3 / 2 - block_offset / 2 );
					}
					block.receiveShadow = true;
					block.castShadow = true;
					scene.add( block );
					blocks.push( block );
				}
			}
		}
	})();
	
	initEventHandling = (function() {
		var _vector = new THREE.Vector3,
			projector = new THREE.Projector(),
			selected_block = null,
			mouse_position = new THREE.Vector3,
			block_offset = new THREE.Vector3,
			handleMouseDown, handleMouseMove, handleMouseUp;
		
		handleMouseDown = function( evt ) {
			var ray, intersections;
			
			_vector.set(
				( evt.clientX / window.innerWidth ) * 2 - 1,
				-( evt.clientY / window.innerHeight ) * 2 + 1,
				1
			);

			projector.unprojectVector( _vector, camera );
			
			ray = new THREE.Ray( camera.position, _vector.subSelf( camera.position ).normalize() );
			intersections = ray.intersectObjects( blocks );
			
			if ( intersections.length > 0 ) {
				selected_block = intersections[0].object;
				
				_vector.set( 0, 0, 0 );
				selected_block.setAngularFactor( _vector );
				selected_block.setAngularVelocity( _vector );
				selected_block.setLinearFactor( _vector );
				selected_block.setLinearVelocity( _vector );
				
				mouse_position.copy( intersections[0].point );
				block_offset.sub( selected_block.position, mouse_position );
				
				intersect_plane.position.y = mouse_position.y;
			}
		};
		
		handleMouseMove = function( evt ) {
			
			var ray, intersection,
				i, scalar;
			
			if ( selected_block !== null ) {
				
				_vector.set(
					( evt.clientX / window.innerWidth ) * 2 - 1,
					-( evt.clientY / window.innerHeight ) * 2 + 1,
					1
				);
				
				projector.unprojectVector( _vector, camera );
				
				ray = new THREE.Ray( camera.position, _vector.subSelf( camera.position ).normalize() );
				intersection = ray.intersectObject( intersect_plane );
				mouse_position.copy( intersection[0].point );
				
				/*
				// this method, while it performs better than the ray trace, has problems as you move away from center of the scene
				scalar = ( mouse_position.y - camera.position.y ) / _vector.y;
				
				mouse_position = _vector.clone().multiplyScalar( scalar ).addSelf( camera.position );
				*/
				
				selected_block.position.add( mouse_position, block_offset );
				selected_block.__dirtyPosition = true;
				
				// Reactivate all of the blocks
				_vector.set( 0, 0, 0 );
				for ( i = 0; i < blocks.length; i++ ) {
					blocks[i].applyCentralImpulse( _vector );
				}
			}
			
		};
		
		handleMouseUp = function( evt ) {
			
			if ( selected_block !== null ) {
				_vector.set( 1, 1, 1 );
				selected_block.setAngularFactor( _vector );
				selected_block.setLinearFactor( _vector );
				
				selected_block = null;
			}
			
		};
		
		return function() {
			renderer.domElement.addEventListener( 'mousedown', handleMouseDown );
			renderer.domElement.addEventListener( 'mousemove', handleMouseMove );
			renderer.domElement.addEventListener( 'mouseup', handleMouseUp );
		};
	})();
	
	window.onload = initScene;
	
	</script>
	
	<style type="text/css">
		html, body {
			margin: 0;
			padding: 0;
			overflow: hidden;
		}
		p {
			font-family: Verdana;
			font-size: 10pt;
			text-align: center;
			position: absolute;
			top: 0;
			width: 100%;
		}
		p a {
			color: #4488ff;
		}
	</style>
</head>

<body>
	<div id="viewport"></div>
</body>

</html>